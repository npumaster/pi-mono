# v86 沙箱评估

v86 是一个用 JavaScript/WebAssembly 编写的 x86 模拟器，可以在浏览器或 Node.js 中运行 Linux。本文档详细介绍了我们将其用作沙箱执行环境的评估。

## 概览

- **是什么**：x86 PC 模拟器（32 位，Pentium 4 级别）
- **如何工作**：运行时将机器码翻译为 WebAssembly
- **客户机操作系统**：Alpine Linux 3.21（32 位 x86）
- **可用包**：Node.js 22, Python 3.12, git, curl 等（完整的 Alpine 仓库）

## 主要发现

### 可行的功能

| 功能 | 状态 | 备注 |
|---------|--------|-------|
| 出站 TCP | ✅ | HTTP, HTTPS, TLS 均正常工作 |
| 出站 UDP | ✅ | DNS 查询正常工作 |
| WebSocket 客户端 | ✅ | 可以连接到外部 WebSocket 服务器 |
| 文件 I/O | ✅ | 9p 文件系统用于主机<->客户机文件交换 |
| 状态保存/恢复 | ✅ | ~80-100MB 状态文件，即时恢复 |
| 包持久化 | ✅ | 已安装的包在保存的状态中持久化 |
| npm install | ✅ | 正常工作（出站 HTTPS） |
| git clone | ✅ | 正常工作（出站 HTTPS） |

### 不可行的功能

| 功能 | 状态 | 备注 |
|---------|--------|-------|
| 入站连接 | ❌ | VM 在 NAT 后（10.0.2.x），需要端口转发 |
| ICMP ping | ❌ | 用户空间网络栈限制 |
| 64 位 | ❌ | v86 仅模拟 32 位 x86 |

## 架构

```
┌─────────────────────────────────────────────────────────┐
│                      Host (Node.js)                      │
│                                                          │
│  ┌──────────────┐     ┌─────────────────────────────┐   │
│  │ rootlessRelay│◄───►│           v86               │   │
│  │  (WebSocket) │     │  ┌─────────────────────┐    │   │
│  │              │     │  │   Alpine Linux      │    │   │
│  │  - DHCP      │     │  │   - Node.js 22      │    │   │
│  │  - DNS proxy │     │  │   - Python 3.12     │    │   │
│  │  - NAT       │     │  │   - etc.            │    │   │
│  └──────────────┘     │  └─────────────────────┘    │   │
│         │             │            │                 │   │
│         │             │     9p filesystem            │   │
│         ▼             │            │                 │   │
│    Internet           │            ▼                 │   │
│                       │     Host filesystem          │   │
│                       └─────────────────────────────┘   │
55→└─────────────────────────────────────────────────────────┘
```

## 组件与大小

| 组件 | 大小 | 用途 |
|-----------|------|---------|
| v86.wasm | ~2 MB | x86 模拟器 |
| libv86.mjs | ~330 KB | JavaScript 运行时 |
| seabios.bin | ~128 KB | BIOS |
| vgabios.bin | ~36 KB | VGA BIOS |
| Alpine rootfs | ~57 MB | 压缩的文件系统（按需加载） |
| alpine-fs.json | ~160 KB | 文件系统索引 |
| rootlessRelay | ~75 KB | 网络中继 |
| **总计** | **~60 MB** | 不含保存的状态 |
| 保存的状态 | ~80-100 MB | 可选，用于即时恢复 |

## 安装

```bash
npm install v86 ws
```

## 构建 Alpine 镜像

v86 提供了 Docker 工具来构建 Alpine 镜像：

```bash
git clone https://github.com/copy/v86.git
cd v86/tools/docker/alpine

# 编辑 Dockerfile 以添加包：
# ENV ADDPKGS=nodejs,npm,python3,git,curl

./build.sh
```

这将创建：
- `images/alpine-fs.json` - 文件系统索引
- `images/alpine-rootfs-flat/` - 压缩的文件块

## 网络中继设置

v86 需要网络中继来进行 TCP/UDP 连接。我们使用 rootlessRelay：

```bash
git clone https://github.com/obegron/rootlessRelay.git
cd rootlessRelay
npm install
```

### 主机访问所需的补丁

为了允许 VM 通过网关 IP (10.0.2.2) 连接到主机服务，请将这些补丁应用到 `relay.js`：

**补丁 1：禁用网关的反向 TCP 处理（约第 684 行）**
```javascript
// 更改前:
if (protocol === 6 && dstIP === GATEWAY_IP) {
  this.handleReverseTCP(ipPacket);
  return;
}

// 更改后:
if (false && protocol === 6 && dstIP === GATEWAY_IP) { // PATCHED
  this.handleReverseTCP(ipPacket);
  return;
}
```

**补丁 2：将网关 TCP 重定向到 localhost（约第 792 行）**
```javascript
// 更改前:
const socket = net.connect(dstPort, dstIP, () => {

// 更改后:
const actualDstIP = dstIP === GATEWAY_IP ? "127.0.0.1" : dstIP;
const socket = net.connect(dstPort, actualDstIP, () => {
```

**补丁 3：将网关 UDP 重定向到 localhost（约第 1431 和 1449 行）**
```javascript
// 更改前:
this.udpSocket.send(payload, dstPort, dstIP, (err) => {

// 更改后:
const actualUdpDstIP = dstIP === GATEWAY_IP ? "127.0.0.1" : dstIP;
this.udpSocket.send(payload, dstPort, actualUdpDstIP, (err) => {
```

### 启动中继

```bash
ENABLE_WSS=false LOG_LEVEL=1 node relay.js
# 监听在 ws://127.0.0.1:8086/
```

## 基本用法

```javascript
import { V86 } from "v86";
import path from "node:path";

const emulator = new V86({
    wasm_path: path.join(__dirname, "node_modules/v86/build/v86.wasm"),
    bios: { url: path.join(__dirname, "bios/seabios.bin") },
    vga_bios: { url: path.join(__dirname, "bios/vgabios.bin") },
    filesystem: {
        basefs: path.join(__dirname, "images/alpine-fs.json"),
        baseurl: path.join(__dirname, "images/alpine-rootfs-flat/"),
    },
    autostart: true,
    memory_size: 512 * 1024 * 1024,
    bzimage_initrd_from_filesystem: true,
    cmdline: "rw root=host9p rootfstype=9p rootflags=trans=virtio,cache=loose modules=virtio_pci tsc=reliable console=ttyS0",
    net_device: {
        type: "virtio",
        relay_url: "ws://127.0.0.1:8086/",
    },
});

// 捕获输出
emulator.add_listener("serial0-output-byte", (byte) => {
    process.stdout.write(String.fromCharCode(byte));
});

// 发送命令
emulator.serial0_send("echo hello\n");
```

## 通信方法

### 1. 串行控制台 (stdin/stdout)

```javascript
// 发送命令
emulator.serial0_send("ls -la\n");

// 接收输出
let output = "";
emulator.add_listener("serial0-output-byte", (byte) => {
    output += String.fromCharCode(byte);
});
```

### 2. 9p 文件系统 (文件 I/O)

```javascript
// 写入文件到 VM
const data = new TextEncoder().encode("#!/bin/sh\necho hello\n");
await emulator.create_file("/tmp/script.sh", data);

// 从 VM 读取文件
const result = await emulator.read_file("/tmp/output.txt");
console.log(new TextDecoder().decode(result));
```

### 3. 网络 (TCP 到主机服务)

在 VM 内部，连接到 `10.0.2.2:PORT` 以访问主机的 `localhost:PORT`（需要修补后的中继）。

```bash
# 在 VM 内部
wget http://10.0.2.2:8080/  # 连接到主机的 localhost:8080
```

## 状态保存/恢复

```javascript
// 保存状态（包括所有已安装的包、文件等）
const state = await emulator.save_state();
fs.writeFileSync("vm-state.bin", Buffer.from(state));

// 恢复状态（即时恢复，~2 秒）
const stateBuffer = fs.readFileSync("vm-state.bin");
await emulator.restore_state(stateBuffer.buffer);
```

## VM 内部网络设置

启动后，运行这些命令以启用网络：

```bash
modprobe virtio-net
ip link set eth0 up
udhcpc -i eth0
```

或者作为单行命令：
```bash
modprobe virtio-net && ip link set eth0 up && udhcpc -i eth0
```

VM 将通过中继从 DHCP 获取 IP `10.0.2.15`（或类似 IP）。

## 性能

| 指标 | 值 |
|--------|-------|
| 冷启动 | ~20-25 秒 |
| 状态恢复 | ~2-3 秒 |
| 内存使用 | ~512 MB（可配置） |

## Mom 的典型工作流

1. **首次运行**:
   - 启动 rootlessRelay
   - 使用 Alpine 启动 v86（~25s）
   - 设置网络
   - 安装所需包 (`apk add nodejs npm python3 git`)
   - 保存状态

2. **后续运行**:
   - 启动 rootlessRelay
   - 恢复保存的状态（~2s）
   - 准备执行命令

3. **命令执行**:
   - 通过 `serial0_send()` 发送命令
   - 通过 `serial0-output-byte` 监听器捕获输出
   - 通过 9p 文件系统交换文件

## 替代方案：fetch 后端（无需中继）

对于仅 HTTP 的网络，v86 有一个内置的 `fetch` 后端：

```javascript
net_device: {
    type: "virtio",
    relay_url: "fetch",
}
```

这使用浏览器/Node.js 的 `fetch()` API 进行 HTTP 请求。限制：
- 仅 HTTP/HTTPS（无原始 TCP/UDP）
- 无 WebSocket
- 主机访问通过 `http://<port>.external`（例如 `http://8080.external`）

## 文件参考

构建后，你需要这些文件：

```
project/
├── node_modules/v86/build/
│   ├── v86.wasm
│   └── libv86.mjs
├── bios/
│   ├── seabios.bin
│   └── vgabios.bin
├── images/
│   ├── alpine-fs.json
│   └── alpine-rootfs-flat/
│       └── *.bin.zst (许多文件)
└── rootlessRelay/
    └── relay.js (已修补)
```

## 资源

- [v86 GitHub](https://github.com/copy/v86)
- [v86 网络文档](https://github.com/copy/v86/blob/master/docs/networking.md)
- [v86 Alpine 设置](https://github.com/copy/v86/tree/master/tools/docker/alpine)
- [rootlessRelay](https://github.com/obegron/rootlessRelay)
- [v86 npm 包](https://www.npmjs.com/package/v86)
